스프링을 사용하지 않은 순수 자바 코드로 회원 멤버십 기능 구축

[회원]
1. 회원 가입 및 조회
2. 회원 종류 - 일반, VIP
3. 외부 시스템과 연동 가능한 자체 DB를 구축하여 회원 데이터 저장(변동 가능)

[주문과 할인 정책]
1. 회원은 상품 주문 가능
2. 현재 VIP 회원은 모든 상품에 대하여 1000원 할인을 적용(변동 가능)

=======================================================================================

[적용된 좋은 객체 지향 설계 3가지 원칙]
1. SRP - 단일 책임 원칙
   -한 클래스는 하나의 책임만 가져야한다.
   -클래스를 클라이언트 객체와 구현 객체로 나눈다.
   -클라이언트 객체는 구현 객체를 실행한다.
   -구현 객체엔 각 기능이 구현되어야 하며, AppConfig에 의해 생성/연결된다.

2. DIP - 의존관계 역전 원칙
   -구체화가 아닌 추상화에 의존해야한다.
   -클라이언트 코드는 추상화 인터페이스에만 의존을 해야한다.
   -AppConfig가 구현 객체 인스턴스를 생성하여 클라이언트 코드에 의존관계를 주입함으로써 클라이언트 코드가 구현 객체를 실행할 수 있도록 함
-

3. OCP
   -확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
   -단순히 AppConfig를 수정함으로써 클라이언트 코드의 의존 관계를 변경할 수 있다.
   -소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀 있음


[IOC - 제어의 역전]
프로그램의 제어 흐름을 외부에서 관리하는 것
AppConfig가 OrderServiceImple, MemberServiceImpl 등의 제어 흐름을 관리


[프레임워크 vs 라이브러리]
프레임워크 : 작성한 코드 제어 및 실행
라이브러리 : 작성한 코드가 직접 제어의 흐름을 담당

[DI - 의존관계 주입]
<정적 클래스 의존관계>
클래스 내 import 코드만으로 의존관계 판단 가능
OrderServiceImpl은 DiscountPolicy, MemberRepository, Member에 의존함 판단 가능

===================================================================================

[스프링 컨테이너 구조]
interface - BeanFactory
|
interface - ApplicationContext
|
AnnotationConfig - ApplicationContext


[BeanFactory]
-스프링 컨테이너의 최상위 인터페이스
-스프링 빈 관리 및 조회
-getBean() 제공

[ApplicationContext]
-BeanFactory 기능을 모두 상속받아 제공
-빈 관리/조회 기능 외에 다른 부가기능 제공
   ==> EX) MassageSource, EnvironmentCapable, ApplicationEventPublisher, ResourceLoader


[스프링 컨테이너의 설정 형식]
<어노테이션 기반 자바 코드>
new AnnotationConfigApplicationContext(AppConfig.class)

<XML>
GenericXmlApplicationContext를 사용하여 xml 설정 파일을 넘긴다.


[의존관계 주입 방법]
1. 생성자 주입
   -생성자 호출 시점에 단 1번만 호출됨을 보장 ==> 차후 생성자를 이용한 인스턴스 재정의를 막을 수 있음
   -불변(값이 바뀌어서는 안된다), 필수(반드시 값이 선언되어야 한다. final) 의존관계에 사용
   -이때, 생성자가 단 1개만 존재한다면 @Autowired 생략 가능(오직 스프링 빈일 경우에만)
   EX) MemberServiceImplComponent, OrderServiceImplComponent
2. 수정자 주입(setter 주입)
   -선택, 변경 가능성이 있는 의존관계에 사용
   -자바빈 프로퍼티 규약의 수정자 메서드 방식 사용
      ==> 필드의 값을 직접 변경하지 않고, getter/setter 메서드를 통해 접근
3. 필드 주입
   -필드(변수)에 바로 주입
   -절대 사용하지 말 것. 굉장히 위험한 코딩. @Configuration과 같은 스프링 설정 테스트 용도로만 사용하자
4. 일반 메서드 주입
   -아무 메서드를 통해 의존관계 주입 ==> 스프링 빈 내에서 사용할 것! 다른 곳은 적용해도 아무 기능도 동작하지 않는다
   -한 번에 여러 필드 주입이 가능하나, 일반적으로 사용 X
   -생성자 주입을 대신하는 메서드들을 선언 가능하나 굳이?

<생성자 주입법이 가장 좋은 이유>
1. 대부분의 의존관계 주입은 애플리케이션의 종료시점까지 불변해야 한다.
2. 수정자 주입 이용시 setter를 public으로 열어야한다. ==> 은닉성이 떨어진다.
3. 생성자 주입은 객체 생성 시 단 1번만 호출되므로, 불변하게 설계 가능
4. 필드에 final 키워드 사용 가능 ==> 컴파일 시점에서 '생성자에서 값 설정 누락 오류'를 막아줌
      ==> 수정자/필드/일반 메서드 주입은 생성자 이후에 호출되므로 final 키워드 사용 불가

[lombok - 롬복]
코드를 최적화해주는 라이브러리

[동일한 타입의 스프링 빈이 두 개 이상 등록되어 있을 때 해결 방법]
-단순히 이름만 다르게 한다고 해결되지 않음
1. @Autowired 필드 명 매칭
   -@Autowired는 타입 - 필드 이름 - 파라미터 이름 순으로 매칭 시도
   -필드 이름을 매칭되기를 원하는 빈 이름으로 변경하면 충돌 회피 가능.
2. @Qualifier
   -동일한 타입의 스프링 빈에 추가 구분자 @Qualifier("이름")을 붙여주는 방법
   -추가 구분자를 지정하는 것이지, 빈 이름을 변경하는 것은 아님
3. @Primary 사용
   -동일한 타입의 빈이 여러개 등록되었을 때, @Primary가 붙은 빈이 우선권을 가진다.
   -@Qualifier가 @Primary보다 우선순위가 높다
